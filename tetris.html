<html>

<head>
    <title> tetris </title>
</head>

<body>
    <div style="text-align: center; top: 50px; position: relative;">
        <canvas id="canvas" width="400" height="600" style="border: 2px solid black;"></canvas>
    </div>

    <script>
        const SCALE_VALUE = 20;
        // Each cell size 20 so width = 400/20 = 20, height = 600/20 = 30
        const BOARD_WIDTH = 20;
        const BOARD_HEIGHT = 30;

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        ctx.scale(SCALE_VALUE, SCALE_VALUE);

        const TETROMINOES = [
            { shape: [[1, 1, 1, 1]], color: "cyan" }, // I
            { shape: [[1, 1], [1, 1]], color: "yellow" }, // O
            { shape: [[1, 1, 1], [0, 1, 0]], color: "purple" }, // T	
            { shape: [[0, 1, 1], [1, 1, 0]], color: "green" }, // S
            { shape: [[1, 1, 0], [0, 1, 1]], color: "red" }, // Z
            { shape: [[1, 0, 0], [1, 1, 1]], color: "blue" }, // J
            { shape: [[0, 0, 1], [1, 1, 1]], color: "orange" } // L

        ];

        let board = create_matrix(BOARD_WIDTH, BOARD_HEIGHT);
        let tetromino = create_tetromino();

        this.interval = setInterval(updateGameArea, 100);

        function updateGameArea() {
            ctx.fillStyle = "WHITE";
            ctx.fillRect(0, 0, BOARD_WIDTH, BOARD_HEIGHT);

            clear_lines()
            draw_board();
            draw_tetromino();

            drop_tetromino();
        }

        function create_tetromino() {
            const randomTetromino = TETROMINOES[Math.floor(Math.random() * TETROMINOES.length)];
            return {
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(randomTetromino.shape[0].length / 2),
                y: 0,
                matrix: randomTetromino.shape,
                color: randomTetromino.color
            };
        }


        function create_matrix(width, height) {
            let m = new Array(height).fill(0);
            for (let i = 0; i < height; i++) {
                m[i] = new Array(width).fill(0);
            }
            return m;
        }

        function draw_tetromino() {
            draw_matrix(tetromino.x, tetromino.y, tetromino.matrix, tetromino.color);
        }

        function draw_board() {
            for (let y = 0; y < board.length; y++) {
                for (let x = 0; x < board[y].length; x++) {
                    if (board[y][x] !== 0) { // Only draw non-empty cells
                        draw_matrix(x, y, [[1]], board[y][x]); // Pass color to draw
                    }
                }
            }
        }

        function draw_matrix(x, y, matrix, color) {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++)
                    if (matrix[i][j] !== 0) {
                        ctx.fillStyle = color;
                        ctx.fillRect(j + x, i + y, 1, 1);
                        // console.log("i: " + i + ", j: " + j);
                    }
            }
        }

        function go_left() {
            tetromino.x--;
            if (hit_land()) {
                tetromino.x++;
            }
        }

        function go_right() {
            tetromino.x++;
            if (hit_land()) {
                tetromino.x--;
            }
        }

        function go_down() {
            tetromino.y++;
            if (hit_land()) {
                // console.log("hit land y: " + tetromino.y);
                tetromino.y--;
                merge_land();
                tetromino = create_tetromino();

            }
        }

        function rotate_tetromino() {
            // Rotate the matrix 90 degrees clockwise
            let rotated = [];
            for (let i = 0; i < tetromino.matrix[0].length; i++) {
                let row = [];
                for (let j = 0; j < tetromino.matrix.length; j++) {
                    row.push(tetromino.matrix[j][i]);
                }
                rotated.push(row);
            }

            rotated.reverse();
            tetromino.matrix = rotated;

        }

        function rotatez_tetromino() {
            rotate_tetromino();
            rotate_tetromino();
            rotate_tetromino();
        }

        function drop_tetromino() {
            tetromino.y++;
            if (hit_land()) {
                tetromino.y--;
                merge_land();
                tetromino = create_tetromino();
            }
        }

        function merge_land() {
            let matrix = tetromino.matrix;
            let x = tetromino.x;
            let y = tetromino.y;
            // console.log(board);
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] !== 0) {  // Only update non-empty cells
                        board[y + i][x + j] = tetromino.color;
                    }
                }
            }
            // console.log(board);
        }

        function hit_land() {
            let matrix = tetromino.matrix;
            let x = tetromino.x;
            let y = tetromino.y;
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (matrix[i][j] !== 0 && (board[y + i] === undefined || board[y + i][x + j] === undefined || board[y + i][x + j] !== 0)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function clear_lines() {
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                let row_full = true;
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (board[y][x] === 0) {
                        row_full = false;
                        break;
                    }
                }
                if (row_full) {
                    board.splice(y, 1); // Remove filled row
                    board.unshift(Array(BOARD_WIDTH).fill(0)); // Add empty row on top
                    y++; // Recheck the same row index after shifting
                }
            }

        }

        document.addEventListener('keydown', handle_keyboard);
        function handle_keyboard(event) {
            switch (event.keyCode) {
                case 37: go_left(); break; // Left arrow
                case 39: go_right(); break; // Right arrow
                case 40: go_down(); break; // Down arrow
                case 38: rotate_tetromino(); break; // Up arrow
                case 90: rotatez_tetromino(); break; // "z"
            }
        }


    </script>
</body>

</html>
